using Sledge.Formats.GameData.Objects;
using System.Net;
using System.Runtime.Serialization;
using System.Text.Json;
using System.Text.RegularExpressions;
using static FGDDumper.EntityPage;
using static FGDDumper.GameFinder;

namespace FGDDumper
{
    public class EntityPage
    {
        public required Game? Game { get; set; }
        public required EntityTypeEnum EntityType { get; set; }
        public string Name { get; init; } = string.Empty;
        public string Description { get; set; } = string.Empty;
        public string IconPath { get; set; } = string.Empty;
        public List<Property> Properties { get; set; } = [];
        public List<InputOutput> InputOutputs { get; set; } = [];

        public enum EntityTypeEnum
        {
            Default,
            Point,
            Mesh
        }

        public string GetMDXText()
        {
            var propertiesString = string.Empty;

            if (Properties.Count > 0)
            {
                propertiesString =
                    $"""
                    <details open>
                    <summary><h2>Keyvalues</h2></summary>

                    """;

                foreach (var property in Properties)
                {
                    propertiesString += property.GetMDXText();
                }

                propertiesString += "\n </details>";
            }


            var inputsString = string.Empty;
            var outputsString = string.Empty;

            var inputs = InputOutputs.Where(x => x.Type == InputOutput.InputOutputTypeEnum.Input).ToList();
            var outputs = InputOutputs.Where(x => x.Type == InputOutput.InputOutputTypeEnum.Output).ToList();

            if (inputs.Count > 0)
            {
                inputsString =
                    $"""
                    <details open>
                    <summary><h2>Inputs</h2></summary>

                    """;

                foreach (var input in inputs)
                {
                    inputsString += input.GetMDXText();
                }

                inputsString += "\n </details>";
            }

            if (outputs.Count > 0)
            {
                outputsString =
                    $"""
                    <details open>
                    <summary><h2>Outputs</h2></summary>

                    """;

                foreach (var output in outputs)
                {
                    outputsString += output.GetMDXText();
                }

                outputsString += "\n </details>";
            }


            string iconText = string.Empty;
            if (!string.IsNullOrEmpty(IconPath))
            {
                var textureImagePath = IconPath;

                if (File.Exists(Path.Combine(EntityPageTools.WikiRoot, textureImagePath)))
                {
                    iconText = $"\nimport {Name}Icon from '@site/{textureImagePath}';\n\n" +
                    $"<img src={{{Name}Icon}} alt=\"{Name} icon\" style={{{{height: '80px'}}}} />\n";
                }

            }

            var MD =
            $"""
            ---
            hide_table_of_contents: true
            ---

            <!---
            !!!!!!
            THIS PAGE IS AUTOGENERATED FROM GAME FGD DEFINITIONS!
            DO NOT EDIT MANUALLY!
            !!!!!!
            
            In order to make edits, you can make an annotation file in /fgd_dump_overrides
            -->
            
            {iconText}
            {EntityType} Entity

            {SanitizeInput(Description)}

            {propertiesString}
            {inputsString}
            {outputsString}
            """;

            return MD;
        }

        public void OverrideFrom(EntityPage overridePage)
        {
            if (overridePage.EntityType != EntityTypeEnum.Default)
            {
                EntityType = overridePage.EntityType;
            }

            if (!string.IsNullOrEmpty(overridePage.Description))
            {
                Description = overridePage.Description;
            }

            if (!string.IsNullOrEmpty(overridePage.IconPath))
            {
                IconPath = overridePage.IconPath;
            }

            foreach (var overrideProperty in overridePage.Properties)
            {
                var matched = false;

                foreach (var property in Properties)
                {
                    if (overrideProperty.InternalName == property.InternalName)
                    {
                        matched = true;
                        property.OverrideFrom(overrideProperty);
                    }
                }

                if (!matched)
                {
                    if (overrideProperty.VariableType == null)
                    {
                        overrideProperty.VariableType = VariableType.Void;
                    }

                    Properties.Add(CloneObject(overrideProperty));
                }
            }

            foreach (var overrideInputOutput in overridePage.InputOutputs)
            {
                var matched = false;

                foreach (var inputOutput in InputOutputs)
                {
                    if (overrideInputOutput.Name == inputOutput.Name)
                    {
                        matched = true;
                        inputOutput.OverrideFrom(overrideInputOutput);
                    }
                }

                if (!matched)
                {
                    InputOutputs.Add(CloneObject(overrideInputOutput));
                }

            }
        }

        public class InputOutput
        {
            public enum InputOutputTypeEnum
            {
                Input,
                Output
            }

            public string Name { get; init; } = string.Empty;
            public string Description { get; set; } = string.Empty;
            public VariableType? VariableType { get; set; }
            public InputOutputTypeEnum? Type { get; set; }

            public string GetMDXText()
            {
                return $"- {Name} \\<`{VariableType}`\\>\\\n{Description}\n\n";
            }

            public void OverrideFrom(InputOutput OverrideInputOutput)
            {
                if (!string.IsNullOrEmpty(OverrideInputOutput.Description))
                {
                    Description = OverrideInputOutput.Description;
                }

                if (OverrideInputOutput.VariableType != null)
                {
                    VariableType = OverrideInputOutput.VariableType;
                }

                if (OverrideInputOutput.Type != null)
                {
                    Type = OverrideInputOutput.Type;
                }
            }
        }

        public class Annotation
        {
            public enum TypeEnum
            {
                Default,
                note,
                tip,
                info,
                warning,
                danger
            }

            public string Message { get; set; } = string.Empty;
            public TypeEnum Type { get; set; } = TypeEnum.Default;
            public string InternalName { get; init; } = string.Empty;

            public string GetMDXText()
            {
                return
                $"""
                   :::{Type}
                   {Message}
                   :::
                """;
            }

            public void OverrideFrom(Annotation overrideAnnotation)
            {
                if (overrideAnnotation.Type != TypeEnum.Default)
                {
                    Type = overrideAnnotation.Type;
                }

                if (!string.IsNullOrEmpty(overrideAnnotation.Message))
                {
                    Message = overrideAnnotation.Message;
                }
            }
        };

        public class Property
        {
            public class Option
            {
                public string Name { get; init; } = string.Empty;
                public string Description { get; set; } = string.Empty;

                public void OverrideFrom(Option overrideOption)
                {
                    if (!string.IsNullOrEmpty(overrideOption.Description))
                    {
                        Description = overrideOption.Description;
                    }
                }
            }

            public string FriendlyName { get; set; } = string.Empty;
            public string InternalName { get; init; } = string.Empty;
            public VariableType? VariableType { get; set; } = null;
            public string Description { get; set; } = string.Empty;

            public List<Option> Options { get; set; } = [];

            public List<Annotation> Annotations { get; set; } = [];

            public string GetMDXText()
            {
                var propertyString = string.Empty;

                // hack to get spawnflags to display properly, for some reason the friendly name is empty for these
                var friendlyName = FriendlyName;
                if (InternalName == "spawnflags")
                {
                    friendlyName = "Spawnflags";
                }

                propertyString = $"- **{friendlyName}** (`{InternalName}`) \\<`{VariableType}`\\>";

                if (!string.IsNullOrEmpty(Description))
                {
                    propertyString += $"\\\n{Description}";
                }

                var options = string.Empty;

                foreach (var option in Options)
                {
                    options += $"  - {option.Name} {option.Description}\n";
                }

                if (!string.IsNullOrEmpty(options))
                {
                    propertyString += "\n" + options;
                }

                foreach (var annotation in Annotations)
                {
                    propertyString += $"\n{annotation.GetMDXText()}";
                }

                propertyString += "\n\n";

                return propertyString;
            }

            public void OverrideFrom(Property overrideProperty)
            {
                if (!string.IsNullOrEmpty(overrideProperty.FriendlyName))
                {
                    FriendlyName = overrideProperty.FriendlyName;
                }

                if (overrideProperty.VariableType != null)
                {
                    VariableType = overrideProperty.VariableType;
                }

                if (!string.IsNullOrEmpty(overrideProperty.Description))
                {
                    Description = overrideProperty.Description;
                }

                foreach (var overrideOption in overrideProperty.Options)
                {
                    var matched = false;

                    foreach (var option in Options)
                    {
                        if (overrideOption.Name == option.Name)
                        {
                            matched = true;
                            option.OverrideFrom(overrideOption);
                        }
                    }

                    if (!matched)
                    {
                        Options.Add(CloneObject(overrideOption));
                    }

                }

                foreach (var overrideAnnotation in overrideProperty.Annotations)
                {
                    var matched = false;

                    foreach (var annotation in Annotations)
                    {
                        if (overrideAnnotation.InternalName == annotation.InternalName)
                        {
                            matched = true;
                            annotation.OverrideFrom(overrideAnnotation);
                        }
                    }

                    if (!matched)
                    {
                        Annotations.Add(CloneObject(overrideAnnotation));
                    }

                }
            }
        }

        public string GetImageRelativeFolder()
        {
            return $"{EntityPageTools.DumpFolder}/img/{Game!.FileSystemName}";
        }

        public string GetImageRelativePath()
        {
            return $"{GetImageRelativeFolder()}/{Name}.png";
        }

        public string GetPageRelativePath()
        {
            return $"{Name}-{Game!.FileSystemName}.mdx";
        }

        public static EntityPage? GetEntityPage(GameDataClass Class, Game game)
        {
            // dont want base classes, users dont care about these
            if (Class.ClassType == ClassType.BaseClass)
            {
                return null;
            }

            EntityTypeEnum entityType = EntityTypeEnum.Point;
            if (Class.ClassType == ClassType.SolidClass)
            {
                entityType = EntityTypeEnum.Mesh;
            }

            string iconPath = string.Empty;

            foreach (var behavior in Class.Behaviours)
            {
                if (behavior.Name == "iconsprite")
                {
                    if (behavior.Values.Count > 0)
                    {
                        iconPath = behavior.Values[0];
                    }
                }
            }

            foreach (var dict in Class.Dictionaries)
            {
                foreach (var kv in dict)
                {
                    if (kv.Key == "image" || kv.Key == "auto_apply_material")
                    {
                        iconPath = (string)kv.Value.Value;
                    }
                }
            }

            var inputOutputs = new List<InputOutput>();
            foreach (var inputOutput in Class.InOuts)
            {
                inputOutputs.Add(new InputOutput
                {

                    Name = inputOutput.Name,
                    Description = SanitizeInput(inputOutput.Description),
                    Type = (InputOutput.InputOutputTypeEnum)Enum.Parse(typeof(InputOutput.InputOutputTypeEnum), inputOutput.IOType.ToString()),
                    VariableType = inputOutput.VariableType
                });
            }

            var entityPage = new EntityPage
            {
                Game = game,
                Name = Class.Name,
                Description = Class.Description,
                IconPath = iconPath,
                EntityType = entityType
            };

            entityPage.InputOutputs.AddRange(inputOutputs);

            foreach (var property in Class.Properties)
            {
                // dont add removed keys pls
                if (property.VariableType == VariableType.RemoveKey)
                {
                    continue;
                }

                var newProperty = new Property
                {
                    FriendlyName = SanitizeInput(property.Description),
                    InternalName = SanitizeInput(property.Name),
                    Description = SanitizeInput(property.Details),
                    VariableType = property.VariableType
                };

                foreach (var option in property.Options)
                {
                    newProperty.Options.Add(new Property.Option
                    {
                        Name = SanitizeInput(option.Description),
                        Description = SanitizeInput(option.Details)
                    });
                }

                entityPage.Properties.Add(newProperty);
            }

            return entityPage;
        }

        private static string EscapeInvalidTags(string input, string[] allowedTags)
        {
            var allowedPattern = string.Join("|", allowedTags.Select(Regex.Escape));

            // match opening tags that are NOT in the allowed list
            var invalidOpenTagPattern = $@"<(?!/?(?:{allowedPattern})\b)[^>]*>";

            return Regex.Replace(input, invalidOpenTagPattern, match =>
                WebUtility.HtmlEncode(match.Value), RegexOptions.IgnoreCase);
        }

        private static string SanitizeInput(string details)
        {
            // make this newline so stuff displays nicely
            details = details.Replace("<br>", "\n");

            // no clue what this does in hammer, seems to be nothing
            // a lot of these are just broken so im removing them outright to avoid confusion
            details = details.Replace("<original name>", "");
            details = details.Replace("<Award Text>", "");
            details = details.Replace("<picker>", "");
            details = details.Replace("<None>", "None");

            // escape any funky tags
            var allowedTags = new[] { "b", "br", "strong" };
            details = EscapeInvalidTags(details, allowedTags);
            // escape unclosed tags at the end
            details = Regex.Replace(details, @"<([^>]*)$", "&lt;$1");
            // escape unclosed tags followed by another opening tag
            details = Regex.Replace(details, @"<([^>]*)(?=<)", "&lt;$1");
            // escape unmatched closing brackets at start
            details = Regex.Replace(details, @"^([^<]*?)>", "$1&gt;");
            // escape unmatched closing brackets after other closing brackets
            details = Regex.Replace(details, @"(?<=>)([^<]*?)>", "$1&gt;");

            details = details.Replace("{", "\\{");
            details = details.Replace("}", "\\}");

            return details;
        }

        // really quite horrible but what can you do
        private static T CloneObject<T>(T objectToClone)
        {
            return JsonSerializer.Deserialize<T>(JsonSerializer.Serialize<T>(objectToClone))!;
        }
    }
}
