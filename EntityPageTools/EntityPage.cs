using System.Net;
using System.Text.Json;
using System.Text.Json.Serialization.Metadata;
using System.Text.RegularExpressions;
using Sledge.Formats.GameData.Objects;
using static FGDDumper.GameFinder;

namespace FGDDumper
{
    public class EntityPage
    {
        public required Game? Game { get; set; }
        public required EntityTypeEnum EntityType { get; set; }
        public string Name { get; set; } = string.Empty;
        public string Description { get; set; } = string.Empty;
        public string IconPath { get; set; } = string.Empty;
        public bool NonFGD { get; set; } = false;
        public bool Legacy { get; set; } = false;
        public List<Property> Properties { get; set; } = [];
        public Annotation? PageAnnotation = null;
        public List<InputOutput> InputOutputs { get; set; } = [];

        public enum EntityTypeEnum
        {
            Default,
            Point,
            Mesh
        }

        public string GetMDXText()
        {
            var propertiesString = string.Empty;

            if (Properties.Count > 0)
            {
                propertiesString =
                $"""
                <details open>
                <summary><h2>Keyvalues</h2></summary>

                """;

                foreach (var property in Properties)
                {
                    propertiesString += property.GetMDXText();
                }

                propertiesString += "\n </details>";
            }


            var inputsString = string.Empty;
            var outputsString = string.Empty;

            var inputs = InputOutputs.Where(x => x.Type == InputOutput.InputOutputTypeEnum.Input).ToList();
            var outputs = InputOutputs.Where(x => x.Type == InputOutput.InputOutputTypeEnum.Output).ToList();

            if (inputs.Count > 0)
            {
                inputsString =
                    $"""
                    <details open>
                    <summary><h2>Inputs</h2></summary>

                    """;

                foreach (var input in inputs)
                {
                    inputsString += input.GetMDXText();
                }

                inputsString += "\n </details>";
            }

            if (outputs.Count > 0)
            {
                outputsString =
                    $"""
                    <details open>
                    <summary><h2>Outputs</h2></summary>

                    """;

                foreach (var output in outputs)
                {
                    outputsString += output.GetMDXText();
                }

                outputsString += "\n </details>";
            }


            string iconText = string.Empty;
            if (!string.IsNullOrEmpty(IconPath))
            {
                var textureImagePath = IconPath;

                if (File.Exists(Path.Combine(EntityPageTools.WikiRoot, textureImagePath)))
                {
                    iconText = $"\nimport {Name}Icon from '@site/{textureImagePath}';\n\n" +
                    $"<img src={{{Name}Icon}} alt=\"{Name} icon\" style={{{{height: '80px'}}}} />\n";
                }

            }

            var MD =
            $"""
            ---
            hide_table_of_contents: true
            ---

            <!---
            !!!!!!
            THIS PAGE IS AUTOGENERATED FROM GAME FGD DEFINITIONS!
            DO NOT EDIT MANUALLY!
            !!!!!!
            
            In order to make edits, you can make an annotation file in /fgd_dump_overrides
            -->
            
            {iconText}
            {EntityType} Entity
            {PageAnnotation?.GetMDXText() ?? string.Empty}
            {WikiFilesGenerator.SanitizeInput(Description)}

            {propertiesString}
            {inputsString}
            {outputsString}
            """;

            return MD;
        }

        public void OverrideFrom(EntityPage overridePage)
        {
            if (overridePage.EntityType != EntityTypeEnum.Default)
            {
                EntityType = overridePage.EntityType;
            }

            if (!string.IsNullOrEmpty(overridePage.Name))
            {
                Name = overridePage.Name;
            }

            if (!string.IsNullOrEmpty(overridePage.Description))
            {
                Description = overridePage.Description;
            }

            if (!string.IsNullOrEmpty(overridePage.IconPath))
            {
                IconPath = overridePage.IconPath;
            }

            if (overridePage.Legacy)
            {
                Legacy = true;
            }

            if (overridePage.NonFGD)
            {
                NonFGD = true;
            }

            if (overridePage.PageAnnotation != null)
            {
                PageAnnotation = overridePage.PageAnnotation;
            }

            foreach (var overrideProperty in overridePage.Properties)
            {
                var matched = false;

                foreach (var property in Properties)
                {
                    if (overrideProperty.InternalName == property.InternalName)
                    {
                        matched = true;
                        property.OverrideFrom(overrideProperty);
                    }
                }

                if (!matched)
                {
                    if (overrideProperty.VariableType == null)
                    {
                        overrideProperty.VariableType = VariableType.Void;
                    }

                    Properties.Add(CloneObject(overrideProperty, JsonContext.Default.Property));
                }
            }

            foreach (var overrideInputOutput in overridePage.InputOutputs)
            {
                var matched = false;

                foreach (var inputOutput in InputOutputs)
                {
                    if (overrideInputOutput.Name == inputOutput.Name)
                    {
                        matched = true;
                        inputOutput.OverrideFrom(overrideInputOutput);
                    }
                }

                if (!matched)
                {
                    InputOutputs.Add(CloneObject(overrideInputOutput, JsonContext.Default.InputOutput));
                }

            }
        }

        public class InputOutput
        {
            public enum InputOutputTypeEnum
            {
                Input,
                Output
            }

            public string Name { get; init; } = string.Empty;
            public string Description { get; set; } = string.Empty;
            public VariableType? VariableType { get; set; }
            public InputOutputTypeEnum? Type { get; set; }

            public string GetMDXText()
            {
                return $"- {Name} \\<`{VariableType}`\\>\\\n{Description}\n\n";
            }

            public void OverrideFrom(InputOutput OverrideInputOutput)
            {
                if (!string.IsNullOrEmpty(OverrideInputOutput.Description))
                {
                    Description = OverrideInputOutput.Description;
                }

                if (OverrideInputOutput.VariableType != null)
                {
                    VariableType = OverrideInputOutput.VariableType;
                }

                if (OverrideInputOutput.Type != null)
                {
                    Type = OverrideInputOutput.Type;
                }
            }
        }

        public class Annotation
        {
            public enum TypeEnum
            {
                Default,
                note,
                tip,
                info,
                warning,
                danger,
                legacy,
                nonFGD
            }

            public string Message { get; set; } = string.Empty;
            public TypeEnum Type { get; set; } = TypeEnum.Default;
            public string InternalName { get; init; } = string.Empty;

            public string GetMDXText()
            {
                return
                $"""
                   :::{Type}
                   {Message}
                   :::
                """;
            }

            public void OverrideFrom(Annotation overrideAnnotation)
            {
                if (overrideAnnotation.Type != TypeEnum.Default)
                {
                    Type = overrideAnnotation.Type;
                }

                if (!string.IsNullOrEmpty(overrideAnnotation.Message))
                {
                    Message = overrideAnnotation.Message;
                }
            }
        };

        public class Property
        {
            public class Option
            {
                public string Name { get; init; } = string.Empty;
                public string Description { get; set; } = string.Empty;

                public void OverrideFrom(Option overrideOption)
                {
                    if (!string.IsNullOrEmpty(overrideOption.Description))
                    {
                        Description = overrideOption.Description;
                    }
                }
            }

            public string FriendlyName { get; set; } = string.Empty;
            public string InternalName { get; init; } = string.Empty;
            public VariableType? VariableType { get; set; } = null;
            public string Description { get; set; } = string.Empty;

            public List<Option> Options { get; set; } = [];

            public List<Annotation> Annotations { get; set; } = [];

            public string GetMDXText()
            {
                var propertyString = string.Empty;

                // hack to get spawnflags to display properly, for some reason the friendly name is empty for these
                var friendlyName = FriendlyName;
                if (InternalName == "spawnflags")
                {
                    friendlyName = "Spawnflags";
                }

                propertyString = $"- **{friendlyName}** (`{InternalName}`) \\<`{VariableType}`\\>";

                if (!string.IsNullOrEmpty(Description))
                {
                    propertyString += $"\\\n{Description}";
                }

                foreach (var annotation in Annotations)
                {
                    propertyString += $"\n{annotation.GetMDXText()}";
                }

                var options = string.Empty;

                foreach (var option in Options)
                {
                    options += $"  - {option.Name}";

                    if (!string.IsNullOrEmpty(option.Description))
                    {
                        options += $"\\\n    {option.Description}\n";
                    }
                    else
                    {
                        options += "\n";
                    }
                }

                if (!string.IsNullOrEmpty(options))
                {
                    propertyString += "\n" + options;
                }

                propertyString += "\n\n";

                return propertyString;
            }

            public void OverrideFrom(Property overrideProperty)
            {
                if (!string.IsNullOrEmpty(overrideProperty.FriendlyName))
                {
                    FriendlyName = overrideProperty.FriendlyName;
                }

                if (overrideProperty.VariableType != null)
                {
                    VariableType = overrideProperty.VariableType;
                }

                if (!string.IsNullOrEmpty(overrideProperty.Description))
                {
                    Description = overrideProperty.Description;
                }

                foreach (var overrideOption in overrideProperty.Options)
                {
                    var matched = false;

                    foreach (var option in Options)
                    {
                        if (overrideOption.Name == option.Name)
                        {
                            matched = true;
                            option.OverrideFrom(overrideOption);
                        }
                    }

                    if (!matched)
                    {
                        Options.Add(CloneObject(overrideOption, JsonContext.Default.Option));
                    }

                }

                foreach (var overrideAnnotation in overrideProperty.Annotations)
                {
                    var matched = false;

                    foreach (var annotation in Annotations)
                    {
                        if (overrideAnnotation.InternalName == annotation.InternalName)
                        {
                            matched = true;
                            annotation.OverrideFrom(overrideAnnotation);
                        }
                    }

                    if (!matched)
                    {
                        Annotations.Add(CloneObject(overrideAnnotation, JsonContext.Default.Annotation));
                    }

                }
            }
        }

        public string GetImageRelativeFolder()
        {
            return $"{EntityPageTools.DumpFolder}/img/{Game!.FileSystemName}";
        }

        public string GetImageRelativePath()
        {
            return $"{GetImageRelativeFolder()}/{Name}.png";
        }

        public string GetPageRelativePath()
        {
            return $"{Name}-{Game!.FileSystemName}.mdx";
        }

        public static EntityPage GetEntityPageFromJson(string filePath)
        {
            var text = File.ReadAllText(filePath);

            if (string.IsNullOrEmpty(text))
            {
                throw new InvalidDataException($"JSON file has empty content! {filePath}");
            }

            var entityPage = JsonSerializer.Deserialize(text, JsonContext.Default.EntityPage);
            if (entityPage == null)
            {
                throw new InvalidOperationException("Failed to deserialise entity page from JSON!");
            }

            return entityPage;
        }

        public static EntityPage? GetEntityPage(GameDataClass Class, Game game)
        {
            // we want base classes only, users dont care about these
            if (Class.ClassType == ClassType.BaseClass || Class.ClassType == ClassType.OverrideClass)
            {
                return null;
            }

            EntityTypeEnum entityType = EntityTypeEnum.Point;
            if (Class.ClassType == ClassType.SolidClass)
            {
                entityType = EntityTypeEnum.Mesh;
            }

            string iconPath = string.Empty;

            foreach (var behavior in Class.Behaviours)
            {
                if (behavior.Name == "iconsprite")
                {
                    if (behavior.Values.Count > 0)
                    {
                        iconPath = behavior.Values[0];
                    }
                }
            }

            foreach (var dict in Class.Dictionaries)
            {
                foreach (var kv in dict)
                {
                    if (kv.Key == "image" || kv.Key == "auto_apply_material")
                    {
                        iconPath = (string)kv.Value.Value;
                    }
                }
            }

            var inputOutputs = new List<InputOutput>();
            foreach (var inputOutput in Class.InOuts)
            {
                inputOutputs.Add(new InputOutput
                {

                    Name = inputOutput.Name,
                    Description = WikiFilesGenerator.SanitizeInput(inputOutput.Description),
                    Type = (InputOutput.InputOutputTypeEnum)Enum.Parse(typeof(InputOutput.InputOutputTypeEnum), inputOutput.IOType.ToString()),
                    VariableType = inputOutput.VariableType
                });
            }

            var entityPage = new EntityPage
            {
                Game = game,
                Name = Class.Name,
                Description = Class.Description,
                IconPath = iconPath,
                EntityType = entityType
            };

            entityPage.InputOutputs.AddRange(inputOutputs);

            foreach (var property in Class.Properties)
            {
                // dont add removed keys pls
                if (property.VariableType == VariableType.RemoveKey)
                {
                    continue;
                }

                var newProperty = new Property
                {
                    FriendlyName = WikiFilesGenerator.SanitizeInput(property.Description),
                    InternalName = WikiFilesGenerator.SanitizeInput(property.Name),
                    Description = WikiFilesGenerator.SanitizeInput(property.Details),
                    VariableType = property.VariableType
                };

                foreach (var option in property.Options)
                {
                    newProperty.Options.Add(new Property.Option
                    {
                        Name = WikiFilesGenerator.SanitizeInput(option.Description),
                        Description = WikiFilesGenerator.SanitizeInput(option.Details)
                    });
                }

                entityPage.Properties.Add(newProperty);
            }

            return entityPage;
        }


        // really quite horrible but what can you do
        private static T CloneObject<T>(T objectToClone, JsonTypeInfo<T> jsonTypeInfo)
        {
            return JsonSerializer.Deserialize(JsonSerializer.Serialize(objectToClone, jsonTypeInfo), jsonTypeInfo)!;
        }
    }
}
